`timescale 1ns / 1ps
module tmr_riscv_alu (
    input  [3:0] A,
    input  [3:0] B,
    input  [2:0] alu_ctrl,
    output [4:0] Y_final,
    output error_flag
);

wire [4:0] Y1, Y2, Y3;

riscv_alu alu1 (.A(A), .B(B), .alu_ctrl(alu_ctrl), .Y(Y1));
riscv_alu alu2 (.A(A), .B(B), .alu_ctrl(alu_ctrl), .Y(Y2));
riscv_alu alu3 (.A(A), .B(B), .alu_ctrl(alu_ctrl), .Y(Y3));

majority_voter mv (
    .Y1(Y1),
    .Y2(Y2),
    .Y3(Y3),
    .Y_final(Y_final),
    .error_flag(error_flag)
);

endmodule

module riscv_alu (
    input  [3:0] A,
    input  [3:0] B,
    input  [2:0] alu_ctrl,
    output reg [4:0] Y
);

always @(*) begin
    case (alu_ctrl)
        3'b000: Y = A + B;          
        3'b001: Y = A - B;         
        3'b010: Y = A & B;          
        3'b011: Y = A | B;          
        3'b100: Y = A ^ B;          
        3'b101: Y = A << 1;         
        3'b110: Y = A >> 1;        
        default: Y = 5'b00000;      
    endcase
end

endmodule

module majority_voter (
    input  [4:0] Y1,
    input  [4:0] Y2,
    input  [4:0] Y3,
    output [4:0] Y_final,
    output error_flag
);

assign Y_final   = (Y1 & Y2) | (Y2 & Y3) | (Y1 & Y3);
assign error_flag = (Y1 != Y2) | (Y2 != Y3) | (Y1 != Y3);

endmodule

module tb_tmr_riscv_alu;

reg  [3:0] A, B;
reg  [2:0] alu_ctrl;
wire [4:0] Y_final;
wire error_flag;

tmr_riscv_alu dut (
    .A(A),
    .B(B),
    .alu_ctrl(alu_ctrl),
    .Y_final(Y_final),
    .error_flag(error_flag)
);

initial begin
    A = 4'd6;
    B = 4'd2;

    alu_ctrl = 3'b000; #10; // ADD
    alu_ctrl = 3'b001; #10; // SUB
    alu_ctrl = 3'b010; #10; // AND
    alu_ctrl = 3'b011; #10; // OR
    alu_ctrl = 3'b100; #10; // XOR

    // Fault Injection
    force dut.alu2.Y = 5'd31; #10;
    release dut.alu2.Y;

    #20 $finish;
end

endmodule

