module qpsk_top(input clk, input rst,
                output signed [15:0] I, Q, I_noisy, Q_noisy,  // ADD THESE
                output [1:0] tx_bits, rx_bits,
                output [15:0] errors, total);

    qpsk_tx tx(.clk(clk), .rst(rst), .I(I), .Q(Q), .tx_bits(tx_bits));
    channel_noise ch(.clk(clk), .I_in(I), .Q_in(Q), .I_out(I_noisy), .Q_out(Q_noisy));
    qpsk_rx rx(.clk(clk), .I(I_noisy), .Q(Q_noisy), .rx_bits(rx_bits));
    ber_counter bc(.clk(clk), .tx_bits(tx_bits), .rx_bits(rx_bits), 
                   .error_count(errors), .total_count(total));
endmodule

module qpsk_tx(input clk, input rst,
               output reg signed [15:0] I,
               output reg signed [15:0] Q,
               output reg [1:0] tx_bits);

    always @(posedge clk) begin
        if (rst) begin
            tx_bits <= 2'b00;
            I <= 16'd0; Q <= 16'd0;
        end else begin
            tx_bits <= tx_bits + 1'b1;
            case(tx_bits)
                2'b00: begin I <=  16'd300; Q <=  16'd300; end  
                2'b01: begin I <=  16'd300; Q <= -16'd300; end
                2'b10: begin I <= -16'd300; Q <=  16'd300; end
                2'b11: begin I <= -16'd300; Q <= -16'd300; end
            endcase
        end
    end
endmodule


module channel_noise(input clk,  // Clock for sample-sync noise
                    input signed [15:0] I_in, Q_in,
                    output reg signed [15:0] I_out, Q_out);

    reg signed [15:0] noise_I, noise_Q;
    
    always @(posedge clk) begin
        // $random() is 32-bit signed [-2^31:2^31-1]; shift/scale to Â±50
        noise_I <= ($random % 101) - 50;  
        noise_Q <= ($random % 101) - 50;
        I_out <= I_in + noise_I;
        Q_out <= Q_in + noise_Q;
    end
endmodule



module qpsk_rx(input clk,
               input signed [15:0] I, Q,
               output reg [1:0] rx_bits);

    parameter TH = 100;  
    always @(posedge clk) begin
        if (I > TH && Q > TH)       rx_bits <= 2'b00;
        else if (I > TH && Q < -TH) rx_bits <= 2'b01;
        else if (I < -TH && Q > TH) rx_bits <= 2'b10;
        else                        rx_bits <= 2'b11;
    end
endmodule



module ber_counter(input clk,
                   input [1:0] tx_bits, rx_bits,
                   output reg [15:0] error_count,
                   output reg [15:0] total_count);

    reg [1:0] tx_bits_d; 
    initial begin
        error_count = 0;
        total_count = 0;
        tx_bits_d = 0;
    end

    always @(posedge clk) begin
        tx_bits_d <= tx_bits;   
        total_count <= total_count + 1;

        if (tx_bits_d != rx_bits)
            error_count <= error_count + 1;
    end
endmodule


module tb_qpsk;
    reg clk, rst;
    wire signed [15:0] I, Q, I_noisy, Q_noisy;
    wire [1:0] tx_bits, rx_bits;
    wire [15:0] errors, total;

    qpsk_top uut(.clk(clk), .rst(rst), 
                 .I(I), .Q(Q), .I_noisy(I_noisy), .Q_noisy(Q_noisy),
                 .tx_bits(tx_bits), .rx_bits(rx_bits),
                 .errors(errors), .total(total));

    initial begin
        clk = 0;
        forever #5 clk = ~clk;
    end

    initial begin
        rst = 1; #30 rst = 0;
        #50;
        
        $monitor("t=%0t tx=%b rx=%b err=%0d/%0d", 
                 $time, tx_bits, rx_bits, errors, total);
        
        #20000 $finish;
    end

    initial begin
        $dumpfile("qpsk.vcd");
        $dumpvars(0, tb_qpsk);
    end
endmodule
